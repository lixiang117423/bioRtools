% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fasta2df.R
\name{fasta2df}
\alias{fasta2df}
\title{Convert FASTA File to Data Frame (High Performance Version)}
\usage{
fasta2df(fasta, validate = TRUE, remove_empty = TRUE, trim_whitespace = TRUE)
}
\arguments{
\item{fasta}{Character vector specifying the path(s) to the FASTA file(s).
Can be a single file path or a vector of file paths for vectorized processing.
Files should contain sequences in standard FASTA format with headers
starting with '>' followed by sequence data on subsequent lines.}

\item{validate}{Logical value indicating whether to perform input validation.
Default is TRUE. Set to FALSE for better performance if input is guaranteed
to be valid.}

\item{remove_empty}{Logical value indicating whether to remove empty sequences.
Default is TRUE.}

\item{trim_whitespace}{Logical value indicating whether to trim whitespace
from sequence headers and sequences. Default is TRUE.}
}
\value{
For single file input: A data frame with two columns:
\describe{
  \item{id}{Character vector containing FASTA headers (including the '>' symbol)}
  \item{seq}{Character vector containing the corresponding DNA/RNA/protein sequences}

# Working with multiple files (vectorized)
fasta_files <- c("seq1.fasta", "seq2.fasta", "seq3.fasta")
results_list <- fasta2df(fasta_files)

# Access individual results
first_file_data <- results_list[[1]]

# Combine all results
all_sequences <- do.call(rbind, results_list)
}

# Integration with tidyverse workflows
\dontrun{
library(dplyr)
library(purrr)

# Method 1: Using rowwise() for line-by-line processing
file_data <- data.frame(
  species = c("species1", "species2", "species3"),
  file_path = c("seq1.fasta", "seq2.fasta", "seq3.fasta")
) %>%
  rowwise() %>%
  mutate(sequences = list(fasta2df(file_path))) %>%
  ungroup()

# Method 2: Using map() for functional programming approach
file_data2 <- data.frame(
  species = c("species1", "species2", "species3"),
  file_path = c("seq1.fasta", "seq2.fasta", "seq3.fasta")
) %>%
  mutate(sequences = map(file_path, fasta2df))

# Method 3: Process all files at once (most efficient)
all_files <- c("seq1.fasta", "seq2.fasta", "seq3.fasta")
all_results <- fasta2df(all_files)  # Returns a list

# Convert to a tidy format
tidy_results <- all_results %>%
  imap_dfr(~ .x %>% mutate(source_file = .y))

# Your specific use case - SOLUTION
dir("G://database/十字花科基因组/叶绿体基因组/chloroplast_genomes/") %>%
  as.data.frame() %>%
  set_names("file") %>%
  filter(!str_detect(file, "network_failed")) %>%
  mutate(
    species = str_split(file, "_chl") %>% map_chr(1),
    path = paste0("G://database/十字花科基因组/叶绿体基因组/chloroplast_genomes/", file)
  ) %>%
  rowwise() %>%  # Key: enables row-by-row processing
  mutate(seq = list(fasta2df(path))) %>%  # Key: use list() wrapper
  ungroup()

# Alternative: Using the tidy wrapper
dir("path/to/files/") %>%
  as.data.frame() %>%
  set_names("file") %>%
  mutate(
    path = paste0("path/to/files/", file),
    seq = map(path, fasta2df_tidy)  # Simpler syntax
  )
}
For multiple file input: A list of data frames, one per input file.
Each data frame has the same structure as the single file output.
The data frame(s) have one row per sequence found in the input file(s).
}
\description{
\code{fasta2df} efficiently converts FASTA format files to R data frames.
This optimized version uses vectorized operations and efficient memory 
allocation to significantly improve performance compared to loop-based approaches.
Suitable for processing large genomic, transcriptomic, or proteomic sequence files.
}
\details{
This function implements several performance optimizations:
\itemize{
  \item Vectorized header detection using \code{startsWith()}
  \item Pre-allocated memory for results to avoid dynamic growth
  \item Efficient string concatenation using \code{paste(..., collapse="")}
  \item Minimal data copying and transformation
}

The function handles various FASTA format variations:
\itemize{
  \item Multi-line sequences (automatically concatenated)
  \item Empty lines (automatically skipped)
  \item Different line ending formats (Unix, Windows, Mac)
  \item Files with or without trailing newlines
}
}
\note{
\itemize{
  \item Large files (>100MB) may require substantial memory
  \item The function loads the entire file into memory
  \item For extremely large files, consider streaming approaches
  \item Sequence names are returned with the '>' prefix intact
}
}
\examples{
\dontrun{
# Create a sample FASTA file for demonstration
fasta_content <- c(
  ">sequence1 description",
  "ATCGATCGATCG",
  "GCTAGCTAGCTA",
  ">sequence2",
  "TTTTAAAA",
  ">sequence3 another description",
  "CCCGGGAAATTT"
)

# Write to temporary file
temp_fasta <- tempfile(fileext = ".fasta")
writeLines(fasta_content, temp_fasta)

# Convert FASTA to data frame
df <- fasta2df(temp_fasta)
print(df)
#   id                           seq
# 1 >sequence1 description      ATCGATCGATCGGCTAGCTAGCTA
# 2 >sequence2                  TTTTAAAA
# 3 >sequence3 another description CCCGGGAAATTT

# Check dimensions
cat("Number of sequences:", nrow(df), "\n")
cat("Average sequence length:", mean(nchar(df$seq)), "\n")

# Clean up
unlink(temp_fasta)
}

# Basic usage with validation disabled for maximum speed
\dontrun{
df_fast <- fasta2df("large_file.fasta", validate = FALSE)
}

# Keep empty sequences and preserve whitespace
\dontrun{
df_raw <- fasta2df("sequences.fasta", 
                   remove_empty = FALSE, 
                   trim_whitespace = FALSE)
}

}
\references{
FASTA format specification: \url{https://en.wikipedia.org/wiki/FASTA_format}
}
\seealso{
\code{\link{readLines}} for reading text files,
\code{\link{Biostrings}} package for advanced sequence manipulation
}
\author{
Optimized by Assistant
}
\keyword{bioinformatics}
\keyword{file}
\keyword{genomics}
\keyword{sequence}
