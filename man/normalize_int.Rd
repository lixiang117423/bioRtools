% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ormalize_int.R
\name{normalize_int}
\alias{normalize_int}
\title{Apply Rank-based Inverse Normal Transformation (INT)}
\usage{
normalize_int(data, feature_col, c = 3/8)
}
\arguments{
\item{data}{A data frame where rows are features (e.g., OTUs, genes) and
columns are samples. It must contain one column with feature identifiers.}

\item{feature_col}{A string specifying the name of the column that contains
the feature identifiers (e.g., `"otu_id"`).}

\item{c}{The Blom offset constant. Defaults to `3/8` as recommended.}
}
\value{
A data frame with the same dimensions as the input `data`, where the
  numeric values have been replaced by their INT-transformed values.
}
\description{
The transformation follows the formula described by Blom:
`y = qnorm((r - c) / (N - 2*c + 1))`, where:
- `r` is the rank of each observation within a feature.
- `N` is the total number of non-missing observations for that feature.
- `c` is the Blom offset constant.
- `qnorm` is the standard normal quantile function.

The function is designed to work within a `tidyverse` pipeline.
}
\details{
This function transforms each row of a data frame (representing features like
OTUs or genes) to a normal distribution using the Rank-based Inverse Normal
Transformation (INT). It's a non-parametric method robust to outliers and
suitable for preparing data for statistical models that assume normality,
such as GWAS.
}
\examples{
library(bioRtools)
# 1. Create a sample dataset with non-normal data
set.seed(123)
sample_data <- data.frame(
  otu_id = paste0("OTU_", 1:5),
  sample_A = rpois(5, lambda = 2)^2,  # Skewed data
  sample_B = rpois(5, lambda = 1),
  sample_C = c(100, 0, 0, 0, 50),     # With outliers and zeros
  sample_D = rpois(5, lambda = 5)
)

print("Original Data:")
print(sample_data)

# 2. Apply the INT normalization
normalized_data <- normalize_int(sample_data, feature_col = "otu_id")

print("Normalized Data:")
print(normalized_data)

# 3. Verify the transformation for one feature (row)
# The result should be perfectly normal (or as close as ranks allow)
# and centered around 0.
transformed_row <- as.numeric(normalized_data[1, -1])
hist(transformed_row, main = "Histogram of a Transformed OTU", xlab = "INT Value")

# Check for normality using a Q-Q plot
qqnorm(transformed_row)
qqline(transformed_row, col = "red")

}
